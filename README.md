# OpenSSL-Common-Modulus-Attack-on-RSA
C implementation of the Common Modulus Attack using OpenSSL open-source library.

Context:
Man in the middle
For this challenge, you will play again the role of the security expert in your company. Your task is to investigate the suspicious traffic generated by one intern workstation (most probably infected with some malware client) sending encrypted data to one server outside the company. Your mission is to understand the behavior of the malware, and to the end finding a way to get clear messages exported to the outside of the company.

After some analysis work, you noticed that the two parties always use a kind of fixed protocol for their communication: the internal application asks for the server’s RSA public key, therefore using the replied key to encrypt transmitted data. Finally, the sender waits for an acknowledgment (ACK) response from server. You observed too that if you cut this ACK response, the client applications resumes the entire protocol for one more time. You tried to act as man in the middle replacing the server’s public key, but in this case, the communication suddenly stopped. For the key exchange, they does not use digital certificates, and you guess they are using instead a somewhat key validation technique, maybe similar with the one used by SSH.  

After many tries, you observed something that could help you with the investigation: if you change only 1 bit of the server’s public key exponent, the client application does not react and go on with data transmission. Of course, in this case, the server is not able to decrypt and therefore it does not send the ACK response. 

Using this behavior, now you are ready to put in place the next man in the middle type attack: during first iteration of the protocol, you catch the server’s key and change 1 bit of this before being received by the client. The server does not send the ACK and the client will resume the protocol with the second iteration. This time you will let the protocol run, saving again the encrypted data uploaded by client to server. 

You sniffed all this traffic:

The server’s original key:
-----BEGIN PUBLIC KEY-----
MIGdMA0GCSqGSIb3DQEBAQUAA4GLADCBhwKBgQCdD6rtwX+8Bb1D+Fs1nMN6caYW
lgTBzzXepC8PDKOSMuPFg3C9ZVmG7pjCrBieGY6vNRyMl3kzgnXebVXHHWLUu0VN
IIPnZeK17VBic5jffZUPTXubEQoMnlIZO22SiWEw+TeoTZMiZkeOMwDW0HZwJUov
tIqz5ky7YdSRKBurxwIBBQ==
-----END PUBLIC KEY-----


The encryption of data in 1st protocol iteration:
9218EE5ADAD937876522AE9521CAF193CB7687D98B2C21089392959B95AFB7417732E136989B6D5B035717C7600E9498DEED75ED3FC44223AF410C002D685F6E719F734639406680FF69582BDA77E5EB79E5605400B41197B72393809BEA4A6ECD8B35AD88516DF2B5F40B6E6856321D3330F2792F76319B643F8B97236AE31

The encryption of data in 2nd  protocol iteration:
BADD5B1B31A370E6BB8E2028F82FD41756E21F1C6B43F56FF6EE4B6D2D083DC06AEBA61170F0253F536430B14C883241CC3B7EFD3017D553765A496B098D424B0234CE4A3779037BAB997360169B5E048019D55D4A5D1D2820FFCC877025B71FCB0D43259ADBCC790000D99A370D615CEF030F2941B0374A3A89FFD6BE8BBCE

The flag is the message text sent by client to the outside server.





Write Up(RO):

Din descrierea protocolului am observat ca la criptare, atat cu cheia public atacata(cu bit schimbat in exponent), cat si la cea corecta a server-ului singurul care va diferi va fi exponentul public, modulul ramand constant => Problema se preteaza atacului Common Modulus asupra RSA.
	
	Atacul presupune exploatarea vulnerabilitatilor introduse la criptarea cu acelasi modul in cheia publica.
	Rationamentul matematic:
		Din identitatea Bezout (e1 * a) + (e2 * b) = GCD(e1, e2) putem obtine coeficientii Bezout a si b.
		Avand captate ambele ciphertext-uri, aplicam:
		c1^a mod n = m^(c1*a) mod n
		c2^b mod n = m^(c2*b) mod n
		Inmultind cele 2 ecuatii intre ele, =>:
		c1^a * c2^b mod n = m^(c1*a + c2*b) mod n = m^GCD(e1,e2) mod n (Din identitatea Bezout)
		Deci, daca rezultatul inmultirii are la exponent GCD(e1,e2), si tinand cont ca noi putem profita de faptul ca putem modifica ORICE bit din exponentul e2 => il modificam in favoare noastra: a.i. GCD(e1,e2)=1
		
		
	In continuare, am recurs la incarcarea cheii din .docx intr-un fisier regular, pe care l-am citit cu utilitarul openssl:
	Cu comanda openssl.exe rsa -pubin -in .\key.pub -text -modulus am extras e1 = 5 si modulul cheii pe care l-am pus in fisierul modulus.in.
	Dupa ce am incarcat si ambele fisiere in cipher1.in si cipher2.in, am implementat in BN-uri rationamentul matematic de mai sus. A fost nevoie sa merg prin incercari pentru a determina e2. Prima optiune a fost e=3,dar nu producea niciun output inteligibil. Asa ca urmatorul e incercat a fost e2=7.
	
	In file.out, programul scoate mesajul in hexa:
	5468652052534127732074657874626F6F6B206D6F646520697320636F6D706C6574656C7920696E7365637572652E20546869732069732077687920525341206E6565647320612072616E646F6D697A65642070616464696E6720736368656D6521
	
	fiind nevoie o conversie HEX -> ASCII pe care am facut-o cu Pugin-ul din Notepad++:
	
	The RSA's textbook mode is completely insecure. This is why RSA needs a randomized padding scheme!

